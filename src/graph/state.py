"""LangGraph state definition for quiz generation workflow."""

from typing import Annotated, Any, Dict, List, Optional

from typing_extensions import TypedDict

from src.models.quiz import Question, Quiz, QuizRound, UserInput

#Merge functions ensure that the agents don't overwrite each others work or it's own previous work
def merge_questions(existing: List[Question], new: List[Question]) -> List[Question]:
    """Merge question lists, replacing by index or appending."""
    if not existing:
        return new
    if not new:
        return existing
    return existing + new


def merge_rounds(existing: List[QuizRound], new: List[QuizRound]) -> List[QuizRound]:
    """Merge round lists."""
    if not existing:
        return new
    if not new:
        return existing

    result = existing.copy()
    for new_round in new:
        for i, existing_round in enumerate(result):
            if existing_round.round_number == new_round.round_number:
                result[i] = new_round
                break
        else:
            result.append(new_round)
    return result

class QuizState(TypedDict, total=False):
    """
    State object shared across all agents in the quiz generation workflow.

    This state is passed through the LangGraph workflow and updated by each agent.
    Using Annotated with reducer functions for proper state merging.
    """

    # User input
    user_input: UserInput

    # Planning phase
    quiz_plan: Optional[Dict[str, Any]]
    """
    Quiz plan created by Planner Agent.
    Structure:
    {
        "title": str,
        "description": str,
        "rounds": [
            {
                "round_number": int,
                "round_name": str,
                "topic": str,
                "question_count": int,
                "difficulty": str
            },
            ...
        ]
    }
    """

    # Generation phase
    raw_questions: Annotated[List[Question], merge_questions]
    """Raw questions generated by Question Generator Agent(s)."""

    # Review phase
    reviewed_questions: Annotated[List[Question], merge_questions]
    """Questions after quality review with scores and feedback."""

    review_feedback: Optional[List[Dict[str, Any]]]
    """Detailed feedback from Quality Reviewer Agent."""

    # Validation phase
    validated_questions: Annotated[List[Question], merge_questions]
    """Questions validated by Answer Validator Agent."""

    validation_issues: Optional[List[Dict[str, Any]]]
    """Any issues found during validation."""

    # Final quiz
    quiz_rounds: Annotated[List[QuizRound], merge_rounds]
    """Organized quiz rounds."""

    final_quiz: Optional[Quiz]
    """Complete quiz object ready for export."""

    # Control flow
    feedback_loop_count: int
    """Number of times questions have been regenerated."""

    max_regeneration_attempts: int
    """Maximum allowed regeneration attempts (default: 3)."""

    current_round_index: Optional[int]
    """Track which round is being processed (for parallel generation)."""

    needs_regeneration: bool
    """Flag indicating if questions need to be regenerated."""

    # Metadata
    errors: Annotated[List[str], lambda x, y: x + y]
    """Accumulate any errors during the workflow."""

    quality_threshold: float
    """Minimum quality score to accept questions (default: 0.7)."""


def create_initial_state(user_input: UserInput) -> QuizState:
    """
    Create the initial state for the quiz generation workflow.

    Args:
        user_input: User's quiz requirements

    Returns:
        Initial QuizState with default values
    """
    return QuizState(
        user_input=user_input,
        quiz_plan=None,
        raw_questions=[],
        reviewed_questions=[],
        review_feedback=None,
        validated_questions=[],
        validation_issues=None,
        quiz_rounds=[],
        final_quiz=None,
        feedback_loop_count=0,
        max_regeneration_attempts=3,
        current_round_index=None,
        needs_regeneration=False,
        errors=[],
        quality_threshold=0.7,
    )